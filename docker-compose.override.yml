# docker-compose.override.yml (robust)
# - Waits for host iptables/DOCKER chain, but never blocks the stack forever.
# - Uses "service_completed_successfully" so services start AFTER the wait finishes.
# - Silences Wireshark host-mode ports warning.
# - Unifies Arkime port mapping and depends on actual service key "os01".

x-waits: &wait_on_docker_ready
  docker-ready:
    condition: service_completed_successfully

services:
  # One-shot wait container. Succeeds after DOCKER chain is present OR after timeout.
  docker-ready:
    image: alpine:3
    network_mode: host
    cap_add: [ "NET_ADMIN" ]
    entrypoint: ["/bin/sh","-lc"]
    command: >
      set -eu;
      # pick an iptables binary if present
      IPT="";
      for b in iptables iptables-legacy iptables-nft; do
        command -v "$b" >/dev/null 2>&1 && IPT="$b" && break;
      done;
      # try to install iptables (best effort)
      if [ -z "${IPT}" ]; then apk add --no-cache iptables >/dev/null 2>&1 || true; fi;
      for b in iptables iptables-legacy iptables-nft; do
        command -v "$b" >/dev/null 2>&1 && IPT="$b" && break;
      done;
      # wait up to ~60s for nat/DOCKER; proceed anyway if still missing
      for i in $(seq 1 30); do
        if [ -n "${IPT}" ] && ${IPT} -t nat -L DOCKER >/dev/null 2>&1; then
          echo "DOCKER chain is ready"; exit 0;
        fi;
        sleep 2;
      done;
      echo "WARN: DOCKER chain not detected after timeout; proceeding anyway";
      exit 0;
    restart: "no"

  # Gate every service that publishes ports (theyâ€™ll start after docker-ready exits)
  portal:
    depends_on:
      <<: *wait_on_docker_ready

  portainer:
    depends_on:
      <<: *wait_on_docker_ready

  mitre-navigator:
    depends_on:
      <<: *wait_on_docker_ready

  wireshark:
    # You run host networking in base, so ports are ignored; silence the warning.
    ports: []

  evebox:
    depends_on:
      <<: *wait_on_docker_ready

  velociraptor:
    depends_on:
      <<: *wait_on_docker_ready

  misp-core:
    depends_on:
      <<: *wait_on_docker_ready
      redis:
        condition: service_healthy
      db:
        condition: service_healthy
      misp-modules:
        condition: service_healthy

  cyberchef:
    depends_on:
      <<: *wait_on_docker_ready

  # Arkime fixes: wait gate + correct service key + unify port mapping
  arkime:
    depends_on:
      <<: *wait_on_docker_ready
      os01:
        condition: service_started
    ports:
      - "${ARKIME_PORT:-7008}:8005"

  fleet-redis:
    depends_on:
      <<: *wait_on_docker_ready

  fleet-server:
    depends_on:
      <<: *wait_on_docker_ready
      fleet-mysql:
        condition: service_healthy
      fleet-redis:
        condition: service_started

  thehive:
    depends_on:
      <<: *wait_on_docker_ready

  elasticsearch:
    depends_on:
      <<: *wait_on_docker_ready

  cortex:
    depends_on:
      <<: *wait_on_docker_ready
      elasticsearch:
        condition: service_started

  wazuh.manager:
    depends_on:
      <<: *wait_on_docker_ready
      generator:
        condition: service_started

  wazuh.indexer:
    depends_on:
      <<: *wait_on_docker_ready
      generator:
        condition: service_started

  wazuh.dashboard:
    depends_on:
      <<: *wait_on_docker_ready
      wazuh.indexer:
        condition: service_started
      generator:
        condition: service_started

  shuffle-frontend:
    depends_on:
      <<: *wait_on_docker_ready
      shuffle-backend:
        condition: service_started

  shuffle-backend:
    depends_on:
      <<: *wait_on_docker_ready

  shuffle-opensearch:
    depends_on:
      <<: *wait_on_docker_ready
      opensearch-init:
        condition: service_started

  openvas:
    depends_on:
      <<: *wait_on_docker_ready
